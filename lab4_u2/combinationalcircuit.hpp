#ifndef _COMBINATION_CIRCUIT_HPP_
#define _COMBINATION_CIRCUIT_HPP_

#include "inputport.hpp"
#include "outputport.hpp"

#include "unaryelement.hpp"
#include "inputportelement.hpp"

#include <unordered_map>
#include <string>
#include <memory>


class CombinationCircuit
{
public:
	CombinationCircuit() = default;
	~CombinationCircuit() = default;
	CombinationCircuit(const CombinationCircuit &) = delete;
	CombinationCircuit & operator = (const CombinationCircuit &) = delete;


	Port const & addInputPort(const std::string & _name, bool _value = false);
	Port const & addOutputPort(const std::string & _name, Element const * _element = nullptr);
	void setPort(const std::string & _name, bool _value);
	bool showPort(const std::string & _name);

	Element const & addInputPortElement(Port const & _port);
	Element const & addUnaryElement(UnaryElement::Action _action, Element const & _element);
	Element const & addBinaryElement();



private:
	std::unordered_map<std::string, std::unique_ptr<Port>> m_ports;
	std::vector<std::unique_ptr<Element>> m_elements;

	Port * findPort(std::string const & _name) const;
};


#endif //_COMBINATION_CIRCUIT_HPP_

/*
абстрактный класс, представляющий все логические элементы(Element) :
	содержит виртуальный деструктор;
	содержит чисто виртуальный метод evaluate, возвращающий значение на выходе элемента(false или true);

производный класс, представляющий одновходовые элементы(UnaryElement) :
	содержит связь с элементом - аргументом - указатель на объект Element без ответственности за уничтожение;
	содержит код операции - буфер или инвертор;
	реализует метод evaluate в соответствии с кодом операции :
		для буфера = > повторяет значение аргумента;
		для инвертора = > возвращает логическое отрицание значения аргумента;

производный класс, представляющий двухвходовые элементы(BinaryElement) :
	содержит 2 связи с элементами - аргументами - указатели на объекты Element без ответственности за уничтожение;
содержит код операции - AND, OR, XOR;
реализует метод evaluate в соответствии с кодом операции(воспользуйтесь прямым эквивалентом с операторами языка - &&, || , ^);

производный класс, представляющий входной порт схемы(InputPortElement) :
	содержит связь с объектом - портом(ссылка на объект InputPort);
реализует метод evaluate считыванием текущего значения, установленного в порте


конкретный класс, представляющий комбинационную схему - CombinationalCircuit:
состоит из набора элементов - указатели на объекты Element с ответственностью за уничтожение;
состоит из набора(наборов) портов - указатели на объекты Port с ответственностью за уничтожение;


базовый класс, представляющий внешний порт схемы(Port) :
	содержит имя порта;
чисто виртуальный метод getValue(), извлекающий его текущее значение;

производный класс, представляющий собой входной порт схемы(InputPort) :
	содержит переменную типа bool, хранящую поданное извне значение, по умолчанию false;
имеет метод для установки текущего значения;
возвращает текущее значение в реализации метода getValue();

производный класс, представляющий собой выходной порт схемы(OutputPort) :
	имеет разрываемую связь с объектом - элементом, чье значение он продвигает на выход схемы;
при реализации метода getValue() :
	при наличии связи, запрашивает значение у обеспечивающего элемента;
при разрыве связи, возвращает false

Создайте текстовый файл “simulation.txt”, содержащий поданные на схему тестовые воздействия :

SET_INPUT a true
SET_INPUT b false
SHOW_PORT c

Разработайте тестовую консольную программу, использующую разработанную иерархию :
напишите функцию, которая создаст объекты любой нетривиальной комбинационной схемы на ваш выбор, известной из курса “Компьютерная логика”(например, мультиплексор с 4 входами данных, 2 входами управления и 1 выходом);
считывайте данные из файла “simulation.txt” и поочередно выполняйте команды :
команда SET_INPUT должна устанавливать текущее значение указанного входного порта(обработайте все возможные здесь ошибки)
команда SHOW_PORT должна печатать на консоли сообщение о текущем значении указанного порта(обработайте все возможные здесь ошибки);
убедитесь в соответствии результатов вашей программы и результатов, известных из теории курса “Компьютерная логика”;
корректно уничтожьте все объекты модели.
*/